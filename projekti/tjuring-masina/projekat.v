
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module projekat(
	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output 	reg     [6:0]		HEX0,
	output	reg	  [6:0]		HEX1,
	output	reg	  [6:0]		HEX2,
	output	reg     [6:0]		HEX3,
	output   reg     [6:0]		HEX4,
	output	reg  	  [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2,

	//////////// SW //////////
	input 	        [9:0]		SW,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,
	output							TX,
	input								RX
);



//=======================================================
//  REG/WIRE declarations
//=======================================================


//=======================================================
//  Structural coding
//=======================================================

	reg[6:0] glava = 0;
	wire clk;
	clkdiv clkdivv(CLOCK_50, clk);
	reg[7:0] inputbajt;
	reg wren;
	wire[6:0] adresa;
	wire[7:0] outputbajt;
	reg [7:0] curr_inst;
	reg [7:0] curr_data;
	reg [6:0] glava2;
	reg [7:0] promena;
	reg [7:0] instr;
	assign LEDR[0] = clk;
	assign LEDR[3:1] = state;
	assign LEDR[9:4] = curr_inst[7:2];
	//UART uart (.clk(clk), .rst(SW[0]), .din(outputbajt), .dout(dout), .vin(wren), .rin(rinctrl), .vout(voutput), .rout(outputr), .rx(RX), .tx(TX));
	//CTRL ctrlb (.din(dout), .reset(SW[0]), .vin(voutput), .r(outputr), .clk(clk), .dout(inputbajt), .wren(wren2), .adr(wradresa));
	// RAM2PORT ram2port (.clock(clk), .data(inputbajt),	.rdaddress(readresa), .wraddress(wradresa), .wren(wren2), .q(q));
	//CTRL2 ctrla (.din(q), .reset(SW[0]), .dugme(SW[1]), .clk(clk), .dout(outputbajt), .adresa(readresa), .posalji(rinctrl), .wren(wren));
	RAM1PORT ram1port (.clock(clk), .data(inputbajt), .address(adresa), .wren(wren), .q(outputbajt));
	reg [2:0] state;
	assign adresa = state ? glava:instr;
	always @(posedge clk) begin
		if(!SW[0]) begin
		glava = 0;
		instr = 64;
		state=0;
		wren = 0;
		end else begin
			case(state)
				0: begin
				end
				1: begin
				 curr_inst <= outputbajt;
				end
				2: begin
				end
				3: begin
				 curr_data <= outputbajt;
				end
				4: begin
				glava2 = glava;
				promena = curr_data;
				if (curr_inst == 8'b00000000) glava2 = glava - 1;
				else if (curr_inst == 8'b00111111) glava2 = glava + 1;
				else if (curr_inst == 8'b11000000) promena = curr_data - 1;
				else if (curr_inst == 8'b11111111) promena = curr_data + 1;
				else if (curr_inst[7:6] == 2'b01 ) instr = instr + (curr_data == 0 ? 0 : curr_inst[5:0] - 1);
				else if (curr_inst[7:6] == 2'b10 ) instr = instr + curr_inst[5:0] - 1;			
				wren = 1;
				inputbajt <= promena;
				end
				5: begin
				wren <= 0;
				glava = glava2;
				instr = instr+1;
				if(instr>127)instr = instr-64;
				end
				default: ;
			endcase
			state = (state+1) % 6;
		end
	end
	
endmodule