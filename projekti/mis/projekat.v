
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
module segment(input [3:0] x,output reg [6:0] broj);
	  always @(*) begin
			case(x)
			0: broj=7'b0111111;
			1: broj=7'b0000110;
			2: broj=7'b1011011;
			3: broj=7'b1001111;

			4: broj=7'b1100110;
			5: broj=7'b1101101;
			6: broj=7'b1111101;
			7: broj=7'b0000111;

			8: broj=7'b1111111;
			9: broj=7'b1101111;
			10: broj=7'b1110111;
			11: broj=7'b1111100;

			12: broj=7'b1011000;
			13: broj=7'b1011110;
			14: broj=7'b1111001;
			15: broj=7'b1110001;
			endcase
			broj=broj^7'b1111111;
	  end
 endmodule

 
 
module projekat(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// PS2 //////////
	inout 		       reg   		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		        reg  		PS2_DAT,
	inout 		          		PS2_DAT2,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		          	   	VGA_BLANK_N,
	output		    reg [7:0]		VGA_B,
	output		            		VGA_CLK,
	output		    reg [7:0]		VGA_G,
	output		    reg      		VGA_HS,
	output		    reg [7:0]		VGA_R,
	output		             		VGA_SYNC_N,
	output		    reg      		VGA_VS
);

/// Mis

	
	reg [25:0] tcnt;
	reg [3:0] bit_cnt;
	reg [16:0] msc;
	reg [6:0] cnt;
	reg [32:0] newdata;
	reg [32:0] data;
	reg [7:0] ign_cnt;
	reg [23:0] leddata;
	
	localparam INHIBIT = 2'b00;
	localparam REQUEST_TO_SEND = 2'b01;
	localparam SENDING = 2'b10;
	localparam FINISH = 2'b11;
	
	reg ucitavamo;
	reg prev_clock;
	reg [1:0] state;
	reg [8:0] cmd;
	reg [7:0] cekaj;
	reg [23:0] px;
	reg [23:0] py;
	reg [23:0] num;
		
	
	localparam RESET_CMD = 9'b011110100;
	wire start_bit = ucitavamo == 1'b0 && PS2_DAT == 1'b0;
	
	always @(negedge CLOCK_50) begin
		case (state)
			INHIBIT: begin
				PS2_CLK <= 1'b0;
				state <= REQUEST_TO_SEND;
			end
			REQUEST_TO_SEND:
				if (tcnt == 26'd5000) begin
					tcnt <= 26'd0;
					PS2_DAT <= 1'b0;
					PS2_CLK <= 1'bz;
					state <= SENDING;
					cmd <= RESET_CMD;
					bit_cnt <= 4'd9;
				end else begin
					tcnt <= tcnt + 26'b1;
				end
			SENDING:
				if (PS2_CLK == 1'b0 && prev_clock == 1'b1) begin
					if (bit_cnt == 4'b0) begin
						PS2_DAT <= 1'bz;
						state <= FINISH;
					end else begin
						PS2_DAT <= cmd[0];
						cmd <= cmd >> 1'b1;
						bit_cnt <= bit_cnt - 4'b1;
					end
				end
			FINISH: begin
				// if (PS2_CLK == 1'b0 && prev_clock == 1'b1) begin
				// end
			end
		endcase
		prev_clock <= PS2_CLK;
	end
	
	wire [23:0] movement_x = {{5'd16{newdata[6]}}, newdata[20:13]};
	wire [23:0] movement_y = {{5'd16{newdata[7]}}, newdata[31:24]};
	
	always @(negedge PS2_CLK) begin
		if (state == FINISH) begin
			if (start_bit) begin
				if(ign_cnt<8'd2) begin
					ign_cnt<=ign_cnt+5'b1;
				end
				else begin
					ucitavamo <= 1'b1;
					newdata <= {PS2_DAT, newdata[32:1]};
					cnt <= cnt + 1'b1;
				end
			end else if (ucitavamo) begin
				newdata <= {PS2_DAT, newdata[32:1]};
				if (cnt == 7'd32) begin
					data <= {PS2_DAT, newdata[32:1]};
					cnt <= 7'b0;
					ucitavamo <= 1'b0;
					
					px = px + movement_x;
					py = py - movement_y;
					if(px<2)
						px=2;
					if(px>799)
						px=799;
					if(py<2)
						py=2;
					if(py>599)
						py=599;
				end else if (cnt == 7'd10 || cnt == 7'd21) begin
					ucitavamo <= 1'b0;
					cnt <= cnt + 1'b1;
				end else begin
					cnt <= cnt + 1'b1;
				end
			end
		end
	end
	
	
	assign LEDR[0]=data[2];
	assign LEDR[1]=data[3];
	assign LEDR[2]=data[1];
	
	wire [23:0] coord = SW[0] ? py : px;
	
	segment aaa(coord[3:0],HEX0);
	segment bbb(coord[7:4],HEX1);
	segment ccc(coord[11:8],HEX2);
	segment ddd(coord[15:12],HEX3);
	segment eee(coord[19:16],HEX4);
	segment fff(coord[23:20],HEX5);







//=======================================================
//  Ekran
//=======================================================
	reg [20:0] brojac = 0;
	reg [10:0] hBrojac = 0;
	reg [8:0] pokret = 0;
	reg [1:0] k = 1;
	reg [8:0] g = 0;

//=======================================================
//  Structural coding
//=======================================================

	// prvi deo
	// postavljanje VGA clock-a
	
	assign VGA_CLK = CLOCK_50;
	assign VGA_SYNC_N = 0;
	assign VGA_BLANK_N = 1;
	
	// ekran jednobojan
	// namestiti timing za horizontalni i vertikalni sync
	
	// clock je 50mhz => svaki puls traje 0.02 * 10^(-6)s
	always @(posedge CLOCK_50) begin
		brojac = brojac + 1;
		
		// TODO: smisliti intelignetniji nacin da se prati dokle smo stigli sa iscrtavanjem.
		//       Deljenje i moduo su izuzetno skupi, pa bi bilo lepo da se izbegnu ukoliko
		//       je moguce
		if (brojac == 692640) begin
			brojac = 0;
			if (pokret > 255 || pokret < 0) begin
				k = k * (-1);
			end
			pokret = pokret + k;
			
		end
		
		// 0.02 * brojac => proteklo vreme do sada u us [MAX = 1s]
		
		// frekvencija osvezavanja ekrana je 72Hz
		// rezolucija je 800 x 600
		
		// skupo, bilo bi dobro smisliti nesto bolje
		hBrojac = brojac % 1040;
		
		// HORIZONTAL TIMING
		if (hBrojac >= 0 && hBrojac < 800) begin
			
			// visible area
			
			// TODO: ove vrednosti treba da se menjaju u buducnosti;
			//       za sada su fiksne - GOTOVO
			//       sledeci korak = gradient - GOTOVO
			//       finalni deo - kvadrat/pravougaonik/sta god
			
			VGA_R = 8'd0;
			VGA_G = 8'd0;
			VGA_B = 8'd0;
			
			if (hBrojac >= px-2 && hBrojac < px+2 && brojac >= (py-2)*1040 && brojac < (py+2)*1040) begin
				VGA_R=8'd255;
				VGA_G=8'd255;
				VGA_B=8'd255;
			end
			
			//horPartBr = horPartBr + 1;
		end
		if (hBrojac >= 800 && hBrojac < 856) begin
			// front porch
			
			VGA_R = 8'd0;
			VGA_G = 8'd0;
			VGA_B = 8'd0;
		end
		if(hBrojac >= 856 && hBrojac < 976) begin
			// sync pulse
			
			// active low => 0 = ON
			VGA_HS = 1;
		end
		if (hBrojac >= 976 && hBrojac < 1040) begin
			// back porch 
			VGA_HS = 0;
			
			VGA_R = 0;
			VGA_G = 0;
			VGA_B = 0;
		end
		
		// VERTICAL TIMING
		if (brojac >= 0 && brojac < 624000) begin
			// visible area
		end
		if (brojac >= 624000 && brojac < 662480) begin
			// front porch
		end
		if (brojac >= 662480 && brojac < 668720) begin
			// sync pulse
			
			// active low => 0 = ON
			VGA_VS = 1;
		end
		if (brojac >= 668720 && brojac < 692640) begin
			// back porch
			VGA_VS = 0;
		end
	end

endmodule